//
// otto.module :: gen.go
//
//   Copyright (c) 2017 Akinori Hattori <hattya@gmail.com>
//
//   Permission is hereby granted, free of charge, to any person
//   obtaining a copy of this software and associated documentation files
//   (the "Software"), to deal in the Software without restriction,
//   including without limitation the rights to use, copy, modify, merge,
//   publish, distribute, sublicense, and/or sell copies of the Software,
//   and to permit persons to whom the Software is furnished to do so,
//   subject to the following conditions:
//
//   The above copyright notice and this permission notice shall be
//   included in all copies or substantial portions of the Software.
//
//   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
//   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
//   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
//   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//   SOFTWARE.
//

// +build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/build"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"unicode/utf8"
)

var (
	o string
	p string
)

func main() {
	wd, err := filepath.Abs(".")
	if err != nil {
		exit(err)
	}
	pkg, err := build.ImportDir(wd, build.ImportComment)
	if err != nil {
		exit(err)
	}

	flag.StringVar(&o, "o", "", "output file")
	flag.StringVar(&p, "p", pkg.Name, "package name")
	flag.Parse()

	switch {
	case len(flag.Args()) < 1:
		os.Exit(1)
	case o == "":
		exit(fmt.Errorf("-o flag is not specified!"))
	}

	root := flag.Arg(0)
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, "// Code generated by \"go run gen.go %v\"; DO NOT EDIT.\n\n", strings.Join(os.Args[1:], " "))
	fmt.Fprintf(buf, "package %v\n\n", p)
	fmt.Fprintf(buf, "var files = map[string][]byte{\n")
	filepath.Walk(root, func(path string, fi os.FileInfo, err error) error {
		switch {
		case err != nil:
			return err
		case !fi.IsDir() && strings.HasSuffix(path, ".js"):
			b, err := ioutil.ReadFile(path)
			if err != nil {
				exit(err)
			}
			fmt.Fprintf(buf, "%q: []byte(", filepath.ToSlash(path[len(root)+1:]))
			if utf8.Valid(b) {
				fmt.Fprintf(buf, "`%s`", sanitize(b))
			} else {
				fmt.Fprintf(buf, "%q", b)
			}
			fmt.Fprintln(buf, "),")
		}
		return nil
	})
	fmt.Fprintln(buf, "}")
	// gofmt
	b, err := format.Source(buf.Bytes())
	if err != nil {
		exit(err)
	}
	// save
	exit(ioutil.WriteFile(o, b, 0666))
}

func exit(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v: %v", os.Args[0], err)
		os.Exit(1)
	}
	os.Exit(0)
}

func sanitize(b []byte) []byte {
	// replace ` with `+"`"+`
	return bytes.Replace(b, []byte("`"), []byte("`+\"`\"+`"), -1)
}
