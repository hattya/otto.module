// Code generated by "modulizer -l core -o core.go lib"; DO NOT EDIT.

package module

type coreLoader struct {
}

func (*coreLoader) Load(id string) ([]byte, error) {
	if b, ok := files[id]; ok {
		return b, nil
	}
	return nil, ErrModule
}

func (*coreLoader) Resolve(id, _ string) (string, error) {
	if _, ok := files[id]; ok {
		return id, nil
	}
	return "", ErrModule
}

var files = map[string][]byte{
	"internal/bootstrap.js": []byte(`//
// otto.module :: internal/bootstrap.go
//
//   Copyright (c) 2017 Akinori Hattori <hattya@gmail.com>
//
//   Permission is hereby granted, free of charge, to any person
//   obtaining a copy of this software and associated documentation files
//   (the "Software"), to deal in the Software without restriction,
//   including without limitation the rights to use, copy, modify, merge,
//   publish, distribute, sublicense, and/or sell copies of the Software,
//   and to permit persons to whom the Software is furnished to do so,
//   subject to the following conditions:
//
//   The above copyright notice and this permission notice shall be
//   included in all copies or substantial portions of the Software.
//
//   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
//   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
//   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
//   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//   SOFTWARE.
//

'use strict';

(function(process) {
  var vm = process.binding('vm');

  function NativeModule(id) {
    this.id = id;
    this.exports = {};
    this.filename = id + '.js';
    this.loaded = false;
  }

  NativeModule._source = process.binding('natives');
  NativeModule._cache = Object.create(null);

  NativeModule.exists = function exists(id) {
    return Object.prototype.hasOwnProperty.call(NativeModule._source, id);
  };

  NativeModule.isInternal = function isInternal(id) {
    var s = 'internal/';
    return id.slice(0, s.length) === s;
  };

  NativeModule.require = function require(id) {
    if (id === 'native_module') {
      return NativeModule;
    }

    var m = NativeModule._cache[id];
    if (!m) {
      NativeModule._cache[id] = m = new NativeModule(id);
      m.compile();
    }
    return m.exports;
  };

  NativeModule.prototype.compile = function compile() {
    var fn = vm.compile(this.filename);
    fn(this.exports, NativeModule.require, this, this.filename);

    this.loaded = true;
  };

  var g = (0, eval)('this');
  g.process = process;

  var Module = NativeModule.require('module');
  var _module = NativeModule.require('internal/module');

  var m = new Module('<otto>');
  g.module = m;
  g.require = _module.require(m);
});
`),
	"internal/module.js": []byte(`//
// otto.module :: internal/module.js
//
//   Copyright (c) 2017 Akinori Hattori <hattya@gmail.com>
//
//   Permission is hereby granted, free of charge, to any person
//   obtaining a copy of this software and associated documentation files
//   (the "Software"), to deal in the Software without restriction,
//   including without limitation the rights to use, copy, modify, merge,
//   publish, distribute, sublicense, and/or sell copies of the Software,
//   and to permit persons to whom the Software is furnished to do so,
//   subject to the following conditions:
//
//   The above copyright notice and this permission notice shall be
//   included in all copies or substantial portions of the Software.
//
//   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
//   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
//   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
//   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//   SOFTWARE.
//

'use strict';

exports.require = function require_(m) {
  var Module = m.constructor;

  function require(id) {
    return m.require(id);
  }

  require.cache = Module._cache;
  require.extensions = Module._extensions;

  require.resolve = function resolve(id) {
    return Module._resolve(id, m);
  };

  return require;
};
`),
	"module.js": []byte(`//
// otto.module :: module.js
//
//   Copyright (c) 2017 Akinori Hattori <hattya@gmail.com>
//
//   Permission is hereby granted, free of charge, to any person
//   obtaining a copy of this software and associated documentation files
//   (the "Software"), to deal in the Software without restriction,
//   including without limitation the rights to use, copy, modify, merge,
//   publish, distribute, sublicense, and/or sell copies of the Software,
//   and to permit persons to whom the Software is furnished to do so,
//   subject to the following conditions:
//
//   The above copyright notice and this permission notice shall be
//   included in all copies or substantial portions of the Software.
//
//   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
//   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
//   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
//   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//   SOFTWARE.
//

'use strict';

var NativeModule = require('native_module');
var _module = require('internal/module');

var vm = process.binding('vm');

var sep = process.platform === 'win32' ? '\\' : '/';
var path = {
  sep: sep,

  dirname: function dirname(path) {
    for (var i = path.length - 1; 0 <= i; i--) {
      if (path[i] === sep) {
        return path.slice(0, i);
      }
    }
    return '.';
  },

  extname: function extname(path) {
    for (var i = path.length - 1; 0 <= i && path[i] !== sep; i--) {
      if (path[i] === '.') {
        return path.slice(i);
      }
    }
    return '';
  },
};

function update(parent, child, scan) {
  if (parent
      && !(scan
           && parent.children.indexOf(child) === -1)) {
    parent.children.push(child);
  }
}

function Module(id, parent) {
  this.id = id;
  this.exports = {};
  this.parent = parent;
  this.filename = null;
  this.loaded = false;
  this.children = [];

  update(parent, this, false);
}

Module._cache = Object.create(null);
Module._pathCache = Object.create(null);
Module._extensions = Object.create(null);

Module._resolve = function _resolve(id, parent) {
  var dir = '';
  if (parent
      && parent.filename) {
    dir = path.dirname(parent.filename);
  }

  var k = id + '\x00' + dir;
  var p = Module._pathCache[k];
  if (!p) {
    Module._pathCache[k] = p = vm.resolve(id, dir);
  }
  return p;
};

Module.prototype.require = function require(id) {
  if (NativeModule.exists(id)
      && !NativeModule.isInternal(id)) {
    return NativeModule.require(id);
  }

  var n = Module._resolve(id, this);
  var m = Module._cache[n];
  if (m) {
    update(this, m, true);
  } else {
    Module._cache[n] = m = new Module(id, this);
    m.filename = n;
    m.paths = [];
    m._load();
  }
  return m.exports;
};

Module.prototype._compile = function _compile() {
  var fn = vm.compile(this.filename);
  fn.call(this.exports, this.exports, _module.require(this), this, this.filename, path.dirname(this.filename));
};

Module.prototype._load = function _load() {
  if (this.loaded) {
    throw new Error('already loaded');
  }

  var ext = path.extname(this.filename);
  if (!(ext in Module._extensions)) {
    ext = '.js';
  }
  Module._extensions[ext](this);
  this.loaded = true;
};

Module._extensions['.js'] = function _extensions$js(module) {
  module._compile();
};

Module._extensions['.json'] = function _extensions$json(module) {
  try {
    module.exports = JSON.parse(vm.load(module.filename));
  } catch (err) {
    throw new err.constructor(module.filename + ': ' + err.message);
  }
};

module.exports = Module;
`),
}
