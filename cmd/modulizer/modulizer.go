//
// otto.module/cmd/modulizer :: modulizer.go
//
//   Copyright (c) 2017-2020 Akinori Hattori <hattya@gmail.com>
//
//   SPDX-License-Identifier: MIT
//

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/build"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

const module = "github.com/hattya/otto.module"

var (
	flagL = flag.String("l", "", "loader prefix")
	flagO = flag.String("o", "", "output file")
	flagP *string
	flagV = flag.String("v", "files", "variable name")
)

var pkg *build.Package

func init() {
	wd, err := filepath.Abs(".")
	if err != nil {
		panic(err)
	}
	pkg, err = build.ImportDir(wd, build.ImportComment)
	if err != nil {
		panic(err)
	}
	flagP = flag.String("p", pkg.Name, "package name")
}

func main() {
	flag.Parse()
	switch {
	case len(flag.Args()) < 1:
		os.Exit(1)
	case *flagO == "":
		exit(fmt.Errorf("-o flag is not specified!"))
	default:
		exit(gen(flag.Arg(0)))
	}
}

func exit(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v: %v\n", os.Args[0], err)
		os.Exit(1)
	}
	os.Exit(0)
}

func gen(root string) error {
	e := errModule(pkg)
	l := loader(*flagL)
	buf := new(bytes.Buffer)
	// header
	fmt.Fprintf(buf, "// Code generated by \"modulizer %v\"; DO NOT EDIT.\n\n", strings.Join(os.Args[1:], " "))
	fmt.Fprintf(buf, "package %v\n\n", *flagP)
	if pkg.ImportPath != module {
		fmt.Fprintf(buf, "import %q\n\n", module)
	}
	// loader
	fmt.Fprintf(buf, "type %v struct {\n", l)
	fmt.Fprintf(buf, "}\n\n")
	// loader.Load
	fmt.Fprintf(buf, "func (l *%v) Load(id string) ([]byte, error) {\n", l)
	fmt.Fprintln(buf, `for _, ext := range []string{"", ".js", ".json"} {`)
	fmt.Fprintf(buf, "if b, ok := %v[id+ext]; ok {\n", *flagV)
	fmt.Fprintln(buf, "return b, nil")
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf, "}")
	fmt.Fprintf(buf, "return nil, %v\n", e)
	fmt.Fprintf(buf, "}\n\n")
	// loader.Resolve
	fmt.Fprintf(buf, "func (*%v) Resolve(id, _ string) (string, error) {\n", l)
	fmt.Fprintln(buf, `for _, ext := range []string{"", ".js", ".json"} {`)
	fmt.Fprintln(buf, "k := id + ext")
	fmt.Fprintf(buf, "if _, ok := %v[k]; ok {\n", *flagV)
	fmt.Fprintln(buf, "return k, nil")
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf, "}")
	fmt.Fprintf(buf, "return \"\", %v\n", e)
	fmt.Fprintf(buf, "}\n\n")
	// variable
	fmt.Fprintf(buf, "var %v = map[string][]byte{\n", *flagV)
	err := filepath.Walk(root, func(path string, fi os.FileInfo, err error) error {
		if err != nil || fi.IsDir() {
			return err
		}
		switch filepath.Ext(path) {
		case ".js", ".json":
			b, err := ioutil.ReadFile(path)
			if err != nil {
				return err
			}
			fmt.Fprintf(buf, "%q: []byte(`%s`),\n", filepath.ToSlash(path[len(root)+1:]), sanitize(b))
		}
		return nil
	})
	if err != nil {
		return err
	}
	fmt.Fprintln(buf, "}")
	// gofmt
	b, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}
	// save
	return ioutil.WriteFile(*flagO, b, 0666)
}

func errModule(pkg *build.Package) string {
	s := "ErrModule"
	if pkg.ImportPath != module {
		s = "module." + s
	}
	return s
}

func loader(s string) string {
	if s == "" {
		return "loader"
	}
	return s + "Loader"
}

func sanitize(b []byte) []byte {
	// replace ` with `+"`"+`
	return bytes.Replace(b, []byte("`"), []byte("`+\"`\"+`"), -1)
}
