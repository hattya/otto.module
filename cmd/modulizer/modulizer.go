//
// modulizer :: modulizer.go
//
//   Copyright (c) 2017 Akinori Hattori <hattya@gmail.com>
//
//   Permission is hereby granted, free of charge, to any person
//   obtaining a copy of this software and associated documentation files
//   (the "Software"), to deal in the Software without restriction,
//   including without limitation the rights to use, copy, modify, merge,
//   publish, distribute, sublicense, and/or sell copies of the Software,
//   and to permit persons to whom the Software is furnished to do so,
//   subject to the following conditions:
//
//   The above copyright notice and this permission notice shall be
//   included in all copies or substantial portions of the Software.
//
//   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
//   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
//   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
//   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//   SOFTWARE.
//

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/build"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"unicode/utf8"
)

const module = "github.com/hattya/otto.module"

var (
	l string
	o string
	p string
	v string
)

func main() {
	wd, err := filepath.Abs(".")
	if err != nil {
		exit(err)
	}
	pkg, err := build.ImportDir(wd, build.ImportComment)
	if err != nil {
		exit(err)
	}

	flag.StringVar(&l, "l", "", "loader prefix")
	flag.StringVar(&o, "o", "", "output file")
	flag.StringVar(&p, "p", pkg.Name, "package name")
	flag.StringVar(&v, "v", "files", "variable name")
	flag.Parse()

	switch {
	case len(flag.Args()) < 1:
		os.Exit(1)
	case o == "":
		exit(fmt.Errorf("-o flag is not specified!"))
	}

	root := flag.Arg(0)
	e := errModule(pkg)
	l = loader(l)
	buf := new(bytes.Buffer)
	// header
	fmt.Fprintf(buf, "// Code generated by \"modulizer %v\"; DO NOT EDIT.\n\n", strings.Join(os.Args[1:], " "))
	fmt.Fprintf(buf, "package %v\n\n", p)
	if pkg.ImportPath != module {
		fmt.Fprintf(buf, "import %q\n\n", module)
	}
	// loader
	fmt.Fprintf(buf, "type %v struct {\n", l)
	fmt.Fprintf(buf, "}\n\n")
	// loader.Load
	fmt.Fprintf(buf, "func (*%v) Load(id string) ([]byte, error) {\n", l)
	fmt.Fprintf(buf, "if b, ok := %v[id]; ok {\n", v)
	fmt.Fprintln(buf, "return b, nil")
	fmt.Fprintln(buf, "}")
	fmt.Fprintf(buf, "return nil, %v\n", e)
	fmt.Fprintf(buf, "}\n\n")
	// loader.Resolve
	fmt.Fprintf(buf, "func (*%v) Resolve(id, _ string) (string, error) {\n", l)
	fmt.Fprintf(buf, "if _, ok := %v[id]; ok {\n", v)
	fmt.Fprintln(buf, "return id, nil")
	fmt.Fprintln(buf, "}")
	fmt.Fprintf(buf, "return \"\", %v\n", e)
	fmt.Fprintf(buf, "}\n\n")
	// variable
	fmt.Fprintf(buf, "var %v = map[string][]byte{\n", v)
	filepath.Walk(root, func(path string, fi os.FileInfo, err error) error {
		switch {
		case err != nil:
			return err
		case !fi.IsDir() && strings.HasSuffix(path, ".js"):
			b, err := ioutil.ReadFile(path)
			if err != nil {
				exit(err)
			}
			fmt.Fprintf(buf, "%q: []byte(", filepath.ToSlash(path[len(root)+1:]))
			if utf8.Valid(b) {
				fmt.Fprintf(buf, "`%s`", sanitize(b))
			} else {
				fmt.Fprintf(buf, "%q", b)
			}
			fmt.Fprintln(buf, "),")
		}
		return nil
	})
	fmt.Fprintln(buf, "}")
	// gofmt
	b, err := format.Source(buf.Bytes())
	if err != nil {
		exit(err)
	}
	// save
	exit(ioutil.WriteFile(o, b, 0666))
}

func exit(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v: %v", os.Args[0], err)
		os.Exit(1)
	}
	os.Exit(0)
}

func errModule(pkg *build.Package) string {
	s := "ErrModule"
	if pkg.ImportPath != module {
		s = "module." + s
	}
	return s
}

func loader(s string) string {
	if s == "" {
		return "loader"
	}
	return s + "Loader"
}

func sanitize(b []byte) []byte {
	// replace ` with `+"`"+`
	return bytes.Replace(b, []byte("`"), []byte("`+\"`\"+`"), -1)
}
